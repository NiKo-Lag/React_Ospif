# REGISTRO DEL PROYECTO - Portal de Gestión OSPIF

Este documento sirve como un registro centralizado del estado, la arquitectura y las decisiones de diseño del proyecto. Se actualizará continuamente a medida que el proyecto evolucione.

---

## 1. Idea General del Proyecto

El proyecto es una aplicación web construida con Next.js que funciona como un portal de gestión para una entidad de salud (posiblemente una obra social o seguro médico). Su funcionalidad principal, hasta ahora, se centra en permitir que los "prestadores" (clínicas, hospitales, etc.) gestionen los procesos de internación de los beneficiarios.

El flujo principal permite a un prestador:
- Autenticarse en un portal seguro.
- Denunciar nuevas internaciones.
- Ver un panel con todas sus internaciones activas y finalizadas.
- Gestionar una internación existente:
    - Solicitar prórrogas.
    - Adjuntar documentación.
    - Finalizar la internación.
- Recibir notificaciones sobre eventos relevantes.

El sistema también presupone la existencia de otros roles, como "Auditores" y "Administradores", aunque sus flujos de trabajo aún no están implementados.

---

## 2. Estructura del Proyecto

El proyecto sigue las convenciones del App Router de Next.js. La estructura principal es la siguiente:

- **`/src/app/`**: Contiene todas las rutas de la aplicación y la lógica de la API.
    - **`/src/app/api/`**: Alberga todos los endpoints del backend, organizados por roles y recursos (ej. `/portal/login`, `/portal/internments`).
    - **`/src/app/portal/`**: Define las rutas del portal de prestadores, que es el área principal para usuarios autenticados. Utiliza un grupo de rutas `(main)` para aplicar un layout específico.
    - **`/src/app/login/`**: (Actualmente no existe como página, pero es una ruta implícita).

- **`/src/components/`**: Contiene todos los componentes reutilizables de React, tanto de UI (`/ui/Modal`) como de lógica de negocio (`/internaciones/ProrrogaForm`).

- **`/src/lib/`**: Contiene lógica y helpers compartidos.
    - `auth.js`: Lógica de autenticación (verificación de tokens JWT).
    - `db.js`: Configuración de la conexión a la base de datos PostgreSQL.

- **`/src/middleware.js`**: (Recientemente añadido) Intercepta las peticiones para proteger las rutas y gestionar las redirecciones basadas en la autenticación.

- **`/storage/`**: Directorio (creado dinámicamente) donde se almacenan los archivos subidos, como la documentación de las internaciones.

---

## 3. Módulos y Relaciones

### a. Módulo de Autenticación

- **Tecnología:** Basado en tokens JWT.
- **Flujo Actual:**
    1. Un "prestador" envía su email y contraseña al endpoint `/api/portal/login/route.js`.
    2. El servidor verifica las credenciales contra la tabla `prestadores` y, si son válidas, genera un JWT.
    3. El token se almacena en una cookie `httpOnly` llamada `provider_token`.
- **Componentes Clave:**
    - `src/lib/auth.js`: Contiene `getSession` y `verifyToken`, helpers para gestionar la sesión.
    - `src/middleware.js`: Protege todas las rutas del portal, redirigiendo al login si no hay un token válido.
- **Estado Actual y Problemas:**
    - **INCONSISTENTE:** Existe una gran inconsistencia en todo el proyecto. Muchos endpoints buscan una cookie llamada `token` en lugar de `provider_token`, lo que hace que fallen.
    - **CÓDIGO DUPLICADO:** La lógica de verificación de token está repetida en casi todos los endpoints y layouts, en lugar de estar centralizada.
    - **FUNCIONALIDADES FALTANTES:** No existen flujos para el registro de usuarios, la recuperación de contraseña o el login de otros roles.

### b. Módulo de Gestión de Internaciones

- **Corazón de la Aplicación:** Es el módulo más desarrollado y complejo.
- **UI Principal:** `src/app/portal/(main)/internments-panel/page.jsx`. Es un componente de cliente complejo que gestiona el estado de la tabla de internaciones y la visibilidad de numerosos modales.
- **API de Soporte:** `src/app/api/portal/internments/`
    - `POST /`: Crea una nueva denuncia de internación, incluyendo la subida de archivos iniciales.
    - `GET /[id]`: Obtiene los detalles completos de una internación.
    - `PATCH /[id]/request-extension`: Añade una solicitud de prórroga al historial de la internación.
    - `PATCH /[id]/upload`: Adjunta nueva documentación a una internación existente.
    - `PATCH /[id]/finalize`: Cambia el estado de la internación a "Finalizada" y registra los detalles del egreso.
- **Relación:** El panel de la UI consume intensivamente estos endpoints para proveer la funcionalidad al prestador.

### c. Módulo de Notificaciones

- **UI:** `src/components/NotificationBell.jsx`. Un componente de cliente que se encarga de mostrar un ícono de campana con las notificaciones no leídas.
- **API de Soporte:** `src/app/api/portal/notifications/`
    - `GET /`: Obtiene todas las notificaciones para el usuario autenticado.
    - `PATCH /[id]`: Marca una notificación específica como leída.
- **Estado Actual:**
    - **NO FUNCIONAL:** Todo el módulo de notificaciones está actualmente roto debido a la inconsistencia en el nombre de la cookie de autenticación que busca en sus endpoints.

### d. Módulo de Auditoría

- **Rol Implícito:** Aunque no tiene una interfaz de usuario visible, el rol de "auditor" es fundamental para el flujo de negocio.
- **Flujo de Trabajo:**
    1. Un "prestador" realiza una acción que requiere aprobación (ej. solicitar una prórroga).
    2. Esta acción crea una "autorización" con el estado `Pendiente de Auditoría`.
    3. Un usuario con el rol de "auditor" debe iniciar sesión (mecanismo aún no descubierto).
    4. El auditor utiliza el endpoint `PATCH /api/auditor/authorizations/[id]` para aprobar, rechazar o devolver la solicitud.
- **Endpoint Clave:** `src/app/api/auditor/authorizations/[id]/route.js`
    - **Verificación de Rol:** Es el único endpoint que verifica explícitamente que el usuario tenga `role: 'auditor'`.
    - **Lógica Detallada:** Actualiza el estado de la autorización, guarda el ID del auditor, la fecha y un comentario.
- **Estado Actual y Problemas:**
    - **FUNCIONALIDAD INCOMPLETA:** No existe un endpoint de login para auditores ni una interfaz de usuario donde puedan ver y gestionar las autorizaciones pendientes. El flujo de trabajo está definido en el backend pero no es utilizable por un usuario final.
    - **INCONSISTENCIA DE AUTENTICACIÓN:** Sufre de los mismos problemas de manejo de tokens que el resto de la aplicación.

### e. Módulo de Administración

- **Rol Placeholder:** La existencia del directorio `/api/admin` sugiere un rol de administrador.
- **Funcionalidades Previstas:** La estructura de subdirectorios (`/users`, `/kpis`) indica que este rol debería encargarse de la gestión de usuarios y la visualización de indicadores.
- **Estado Actual:**
    - **NO IMPLEMENTADO:** Los directorios que contendrían la lógica de la API para este rol están completamente vacíos. Es un rol puramente conceptual en esta etapa del proyecto.

### f. Integración con API Externa (SAAS)

- **Descubrimiento Arquitectónico:** El proyecto no gestiona su propio padrón de beneficiarios. Actúa como un intermediario (Backend-For-Frontend) que consulta una API de terceros para esta información.
- **Endpoint Clave:** `GET /api/beneficiary/[cuil]`
    - Este endpoint es consumido por el asistente de denuncia de internación para validar y obtener los datos del paciente.
- **Flujo de Interacción:**
    1. El backend de la aplicación recibe la petición del frontend.
    2. Se autentica contra la API de SAAS (`https://fosforo.client-api.saas.com.ar/api`) usando credenciales fijas para obtener un token temporal.
    3. Utiliza ese token para consultar el padrón de SAAS con el CUIL proporcionado.
    4. Normaliza los datos recibidos (ej. corrige nombres faltantes) y los devuelve al frontend.
- **Estado Actual y Problemas:**
    - **VULNERABILIDAD DE SEGURIDAD:** Las credenciales para la API de SAAS están hardcodeadas en el código fuente en lugar de usar variables de entorno. Esto es un riesgo de seguridad crítico.
    - **INCONSISTENCIA DE AUTENTICACIÓN:** El endpoint que envuelve esta lógica sufre del mismo problema de verificación de tokens que el resto de la aplicación.

### g. Dependencias y Configuración del Proyecto (package.json)

- **Descubrimiento Crítico (Contradicción):** El archivo `package.json` incluye la dependencia `@auth0/nextjs-auth0`. Esto contradice frontalmente el sistema de autenticación manual (JWT + bcrypt) que está implementado en todo el proyecto.
- **Hipótesis Principal:** El proyecto probablemente comenzó o intentó una migración hacia Auth0, pero esta fue abandonada. El sistema de autenticación manual existente es el resultado de esa decisión, pero quedó en un estado inconsistente y a medio terminar. El directorio `/src/app/api/auth/[...auth0]/` (actualmente vacío) es un remanente de este intento.
- **Múltiples Bases de Datos:** Se declaran dependencias tanto para `pg` (PostgreSQL) como para `better-sqlite3` (SQLite). Toda la lógica de negocio visible utiliza PostgreSQL. SQLite podría haber sido usado en una fase temprana o para desarrollo local.
- **Stack Tecnológico:**
    - **Framework:** Next.js
    - **UI:** React, TailwindCSS, Framer Motion, Heroicons
    - **Backend:** Node.js
    - **Bases de Datos:** PostgreSQL, (posiblemente SQLite)

### h. Scripts de Utilidad

- **`hashPassword.js`:**
    - **Propósito:** Un script de línea de comandos para generar hashes de contraseñas usando `bcrypt`.
    - **Flujo de Trabajo Implícito:** Confirma que la creación de usuarios y la asignación de contraseñas se realizan de forma manual, directamente en la base de datos. El script facilita la generación del hash necesario para las consultas SQL.
    - **Implicación:** Refuerza la conclusión de que las funcionalidades de registro de usuarios y gestión de perfiles son inexistentes en la aplicación.

---
## 4. Estado General y Próximos Pasos (Inicial)

El proyecto tiene una base de lógica de negocio muy sólida y bien implementada, principalmente para el rol de "prestador". Su arquitectura es más compleja de lo que parecía inicialmente, funcionando como un orquestador entre su propia base de datos (PostgreSQL) y un servicio externo (SAAS) para el padrón de afiliados.

Sin embargo, está severamente afectado por un sistema de autenticación fragmentado, inconsistente y a medio hacer. Los roles de "auditor" y "admin" están en fases muy tempranas de desarrollo y no son funcionales.

**El primer gran objetivo, antes de añadir cualquier nueva funcionalidad, será refactorizar y unificar todo el sistema de autenticación.** Esto implicará:
1. Estandarizar el uso de `getSession` en todos los endpoints y layouts para obtener la sesión del usuario.
2. Eliminar toda la lógica de verificación de tokens duplicada.
3. Asegurar que todos los endpoints utilicen el nombre de cookie correcto.
4. Corregir los módulos que actualmente no funcionan (como Notificaciones) como resultado de este refactor.

---
## 5. Plan de Acción y Decisiones Arquitectónicas

### Fase 1: Limpieza y Actualización (Completada)

- **Decisión:** Antes de implementar cualquier funcionalidad nueva o corregir los problemas existentes, se decidió actualizar la base tecnológica del proyecto y eliminar el código muerto y las dependencias no utilizadas.
- **Acciones Realizadas:**
    1.  Se actualizaron las dependencias principales (`next`, `react`, `react-dom`) a sus últimas versiones estables.
    2.  Se desinstaló el paquete `@auth0/nextjs-auth0`.
    3.  Se eliminó el directorio de API remanente `src/app/api/auth`.
- **Resultado:** El proyecto ahora se ejecuta sobre una versión moderna de Next.js y está libre de los restos de la integración abandonada con Auth0.

### Fase 2: Implementación de NextAuth (Próximo Paso)

- **Decisión Arquitectónica:** Se ha decidido utilizar **NextAuth.js** (ahora parte de Auth.js) como la librería principal para gestionar toda la autenticación y autorización.
- **Justificación:**
    - Es el estándar de facto para la autenticación en aplicaciones Next.js.
    - Centraliza toda la lógica de autenticación (logins, sesiones, tokens, etc.) en un único lugar, eliminando el código duplicado y las inconsistencias.
    - Es altamente extensible y nos permitirá implementar fácilmente diferentes "providers" de credenciales para los distintos roles (Prestadores, Auditores, etc.).
    - Proporciona ganchos y helpers del lado del cliente y del servidor (`useSession`, `getSession`) que simplificarán enormemente el código en los componentes y las API routes.
- **Plan de Implementación:**
    1. Instalar NextAuth.
    2. Crear el endpoint "catch-all" `src/app/api/auth/[...nextauth]/route.js`.
    3. Configurar el "CredentialsProvider" para manejar el login de los "Prestadores" (validando contra la base de datos con `bcrypt`).
    4. Refactorizar todos los endpoints de la API y los componentes de la UI para utilizar los helpers de NextAuth (`getSession`, `useSession`) en lugar de la lógica manual de verificación de tokens.
    5. Asegurar que el `middleware` utilice la lógica de NextAuth para proteger las rutas.
    6. Eliminar el código de autenticación manual obsoleto (`src/lib/auth.js`).

### Fase 3: Desarrollo de Nuevas Funcionalidades (Próximo Paso)

- **Decisión:** Habiendo establecido una base de código estable y moderna, el siguiente paso es abordar las funcionalidades incompletas o inexistentes.
- **Plan Propuesto:**
    1.  **Implementar el login para el rol de "Auditor"**: Añadir un segundo `CredentialsProvider` o una lógica condicional en el existente para manejar el login de auditores.
    2.  **Desarrollar la Interfaz de Usuario del Auditor**: Crear las páginas y componentes necesarios para que un auditor pueda ver su panel de autorizaciones pendientes y actuar sobre ellas.
    3.  **Implementar el Flujo de Registro de Usuarios (Prestadores)**: Crear la página de registro y el endpoint de API correspondiente.
    4.  **Implementar la Recuperación de Contraseña.**
    5.  **Desarrollar las funcionalidades del rol de "Admin"**.

### Fase 4: Unificación de la Página de Login (Completada)

- **Decisión Arquitectónica:** Se decidió unificar el punto de entrada de la aplicación en una única página de login genérica para todos los roles, en lugar de tener páginas separadas (ej. `/portal/login`, `/auditor/login`).
- **Justificación:** Mejora la experiencia de usuario, simplifica el mantenimiento y refuerza el concepto de una única aplicación con diferentes roles.
- **Acciones Realizadas:**
    1.  Se creó una nueva página de login en `src/app/login/page.jsx`, conservando el diseño visual preferido.
    2.  Se actualizó la configuración de NextAuth (`pages: { signIn: '/login' }`) para que todas las redirecciones de autenticación apunten a esta nueva página.
    3.  Se refactorizó la lógica de `authorize` en el `CredentialsProvider` para que sea capaz de buscar usuarios en diferentes tablas (actualmente busca en `prestadores` y está preparado para buscar en `users`).
    4.  Se eliminó la antigua página de login (`/src/app/portal/login`).
- **Resultado:** La aplicación ahora tiene un único punto de entrada de autenticación, más limpio, escalable y fácil de mantener.

### Fase 17: Implementación del Rol de Operador y Refinamiento del Flujo de Auditoría (Completada)

- **Requerimiento:** Introducir un nuevo rol de usuario, `operador`, con permisos para crear y gestionar solicitudes de autorización antes de que pasen a auditoría, y refinar las reglas de negocio sobre cuándo se notifican las acciones de auditoría a los prestadores.
- **Decisión Arquitectónica:** Se decidió integrar el nuevo rol en los flujos y componentes existentes para mantener la coherencia y reutilizar el código. La lógica de negocio más compleja y específica se centralizó en el backend para garantizar la seguridad y la correcta aplicación de las reglas.
- **Acciones Técnicas Realizadas:**
    1.  **Creación del Rol `operador`:**
        -   Se actualizó el layout de gestión interna (`/app/(app)/layout.js`) para reconocer el rol `operador`, proporcionándole un menú con acceso al Dashboard y a la página de Autorizaciones.
        -   Se actualizaron los permisos en los endpoints de la API relevantes (`PATCH /api/autorizaciones/[id]`) para permitir que los operadores realicen acciones específicas, como cambiar el estado de una solicitud.
    2.  **Implementación del Flujo "Enviar a Auditoría":**
        -   Se potenció el modal de detalle de la autorización (`AuthorizationForm.jsx`) para que muestre un botón "Enviar a Auditoría" de forma condicional.
        -   Este botón es visible únicamente para el rol `operador` y solo cuando la solicitud se encuentra en el estado `'Nuevas Solicitudes'`.
        -   Al hacer clic, el botón llama al endpoint `PATCH /api/autorizaciones/[id]` para cambiar el estado a `'En Auditoría'`, registrando automáticamente el evento en la trazabilidad.
    3.  **Refinamiento de la Lógica de Notificaciones:**
        -   Se modificó el endpoint de acciones del auditor (`PATCH /api/auditor/authorizations/[id]`) para implementar una lógica de notificación diferencial y más precisa.
        -   **Para autorizaciones asociadas a internaciones (`internment_id` no es nulo):** Se notifica al prestador de cualquier acción relevante del auditor (Aprobar, Rechazar, Devolver).
        -   **Para autorizaciones independientes (`internment_id` es nulo):** Solo se notifica al prestador si la solicitud es **aprobada**, ya que es el único caso que requiere una acción por su parte.
- **Resultado:** Se ha definido y materializado un nuevo rol de `operador` con un flujo de trabajo claro y seguro dentro del sistema. Además, la lógica de comunicación con el prestador se ha hecho más inteligente y contextual, evitando notificaciones innecesarias y asegurando que la información llegue en el momento preciso, de acuerdo con las reglas de negocio.

### Fase 18: Módulo de Auditorías de Terreno (Completada)

- **Requerimiento:** Implementar una nueva funcionalidad que permita al personal interno solicitar una auditoría presencial (de terreno) para una internación específica, asignarla a un médico auditor y que este último pueda registrar el resultado de su visita.
- **Decisión Arquitectónica:** Se diseñó un flujo de trabajo de dos fases (solicitud y ejecución) y se crearon nuevas tablas en la base de datos (`field_audits`, `field_audit_documents`) para dar soporte a esta funcionalidad de forma aislada pero relacionada con las internaciones.
- **Acciones Técnicas Realizadas:**
    1.  **Ampliación del Esquema de la Base de Datos:**
        -   Se crearon dos nuevas tablas: `field_audits` para almacenar la información de la auditoría (quién solicita, a quién se asigna, estado, etc.) y `field_audit_documents` para futuros adjuntos.
    2.  **Backend (API para el Flujo Completo):**
        -   Se creó el endpoint `POST /api/internments/[id]/field-audits` para que un usuario con rol `operador` o `admin` pueda crear una solicitud de auditoría, asignándola a un auditor específico.
        -   Se creó el endpoint `PUT /api/field-audits/[audit_id]` para que el auditor asignado pueda completar el informe, actualizando el estado de la auditoría y registrando los detalles de la visita (fecha, observaciones, checklist).
    3.  **Frontend (Integración en la Interfaz Existente):**
        -   Se modificó el modal de detalle de la internación (`InternmentDetailModal.jsx`) para añadir una nueva sección "Acciones Disponibles", donde los usuarios autorizados ven un botón para "Solicitar Auditoría Terreno".
        -   Al hacer clic, se abre un nuevo modal con el formulario `FieldAuditRequestForm.jsx`, que permite seleccionar al auditor y añadir un motivo.
        -   Se añadió una sección "Auditorías de Terreno" en el mismo modal de detalle, que lista todas las auditorías asociadas a esa internación, mostrando su estado (`Pendiente`, `Completada`).
        -   Si una auditoría está pendiente y el usuario actual es el auditor asignado, se muestra un botón "Completar Informe", que abre el formulario `FieldAuditCompletionForm.jsx`.
- **Resultado:** La aplicación ahora cuenta con un ciclo de vida completo para las auditorías de terreno. El proceso es claro, trazable y está perfectamente integrado en la vista de detalle de la internación, permitiendo una gestión centralizada de todas las actividades relacionadas sin abandonar el contexto del paciente.

### Fase 19: Flujo de Envío a Auditoría para Internaciones (Completada)

- **Requerimiento:** Crear un mecanismo para que el personal interno (rol `operador` o `admin`) pueda iniciar formalmente el proceso de auditoría para una internación que se encuentra en estado `INICIADA`.
- **Problema Detectado:** El sistema solo contemplaba que una auditoría se iniciara como consecuencia de una acción del prestador (ej. solicitar prórroga), pero no existía una vía para que el equipo interno disparara este proceso proactivamente.
- **Decisión Arquitectónica:** Se decidió implementar un flujo que es coherente con el resto de la aplicación: la acción del operador debe crear una `autorización` vinculada a la `internación`. Esta nueva autorización será el vehículo para el proceso de auditoría, centralizando la lógica en el módulo de autorizaciones ya existente.
- **Acciones Técnicas Realizadas:**
    1.  **Backend (Nuevo Endpoint Dedicado):**
        -   Se creó el endpoint `POST /api/internments/[id]/send-to-audit`.
        -   Este endpoint realiza una operación atómica (envuelta en una transacción) que:
            a.  Verifica que el usuario sea `operador` o `admin`.
            b.  Valida que la internación esté en estado `INICIADA`.
            c.  Crea un nuevo registro en la tabla `authorizations` de tipo "Internación", con estado `'En Auditoría'` y con los datos relevantes de la internación.
            d.  Actualiza el estado de la `internment` original a `'EN AUDITORIA'`.
    2.  **Frontend (Integración en la Interfaz de Operador):**
        -   Se modificó el modal de detalle de la internación (`InternmentDetailModal.jsx`).
        -   Se añadió un nuevo botón, "Enviar a Auditoría", en la sección de "Acciones Disponibles".
        -   Este botón es visible únicamente para los roles `operador` y `admin`, y solo cuando la internación se encuentra en estado `INICIADA`.
        -   Al hacer clic, el botón llama al nuevo endpoint, proporcionando feedback visual al usuario (estado de carga) y mostrando una notificación de éxito o error.
- **Resultado:** Se ha cerrado una brecha importante en el flujo de trabajo. El personal interno ahora tiene el control total para iniciar el proceso de auditoría de una internación en el momento oportuno, siguiendo un patrón de diseño consistente que aumenta la trazabilidad y reutiliza la lógica de negocio existente.

### Fase 20: Depuración de Regresiones y Estabilización (Completada)

- **Requerimiento:** Solucionar una serie de errores críticos que surgieron tras la implementación de nuevas funcionalidades, los cuales afectaron tanto al portal de prestadores como a la gestión interna.
- **Problema Detectado:** Una cascada de errores interconectados:
    1.  **Regresión en Portal de Prestadores:** Los prestadores experimentaban un error 500 al intentar ver los detalles de una internación, bloqueando funcionalidades clave como la solicitud de prórrogas o la subida de documentación.
    2.  **Error de Referencia en Gestión Interna:** Al mismo tiempo, los operadores internos se encontraban con un error de crasheo (`ReferenceError: canRequestAudit is not defined`) al abrir el mismo modal de detalles de internación.
- **Proceso de Diagnóstico y Decisión Arquitectónica:**
    - Se identificó que la **causa raíz del error 500** era una modificación en el endpoint `GET /api/portal/internments/[id]`. En un intento por mostrar las auditorías de terreno, se añadió una consulta a la tabla `field_audits` que no existía en el entorno de producción, causando el fallo de la API. La decisión fue **comentar temporalmente** esta funcionalidad para restaurar el servicio inmediatamente.
    - Se descubrió que el **`ReferenceError`** fue causado por la eliminación accidental del hook `useMemo` que calculaba la variable `canRequestAudit` durante una limpieza de código en `InternmentDetailModal.jsx`. La decisión fue **restaurar inmediatamente** el código eliminado.
- **Acciones Técnicas Realizadas:**
    1.  **Backend (Hotfix Crítico):**
        -   Se modificó `GET /api/portal/internments/[id]/route.js`.
        -   Se comentó el bloque de código que realizaba el `LEFT JOIN` con la tabla `field_audits` y que añadía los resultados al objeto de respuesta. Esto estabilizó inmediatamente el portal de prestadores.
    2.  **Frontend (Restauración de Lógica):**
        -   Se modificó `src/components/internaciones/InternmentDetailModal.jsx`.
        -   Se reintrodujo el hook `useMemo` que define la constante `canRequestAudit`, basándose en el rol del usuario de la sesión. Esto corrigió el crash en el portal de gestión interna.
- **Resultado:** Se estabilizó la aplicación, resolviendo dos bugs críticos que afectaban a diferentes perfiles de usuario. La lección aprendida fue la importancia crítica de las pruebas de regresión exhaustivas, verificando que los cambios en un área (gestión interna) no introduzcan efectos secundarios inesperados en otra (portal de prestadores). La funcionalidad de visualización de auditorías de terreno queda pendiente de una reimplementación segura.

### Fase 21: Funcionalidad Completa del Flujo del Operador (Completada)

- **Requerimiento:** Retomar y solucionar el problema original por el cual un `operador` no podía visualizar ni gestionar las internaciones que creaba.
- **Proceso de Depuración Iterativo:** Se abordó una cadena de bugs interconectados que impedían la funcionalidad.
    1.  **Visibilidad en Tablero (Error 404):**
        -   **Problema:** La página de autorizaciones llamaba a un endpoint (`/api/autorizaciones-internas`) que no existía.
        -   **Solución:** Se decidió, por organización, crear el endpoint en `GET /api/autorizaciones/internas`. Se implementó la lógica para combinar prácticas e internaciones, y se corrigió el `fetch` del frontend.
    2.  **Error de Compilación del Backend (`Module not found`):**
        -   **Problema:** El nuevo endpoint tenía una ruta de importación incorrecta para `authOptions`.
        -   **Solución:** Se corrigió la ruta relativa de `../../../` a `../../`, permitiendo que el backend compilara.
    3.  **Carga Defectuosa de Detalles del Modal:**
        -   **Problema:** Al hacer clic en "Ver Detalle", el modal cargaba datos incorrectos o incompletos.
        -   **Diagnóstico:** Se descubrió que el modal llamaba a un endpoint del portal de prestadores (`/api/portal/internments/[id]`) en lugar de uno de gestión interna.
        -   **Solución:** Se creó un nuevo endpoint dedicado y seguro para la gestión interna en `GET /api/internments/[id]` y se actualizó la lógica del modal para usarlo si el usuario es un rol interno.
    4.  **Error de Renderizado Visual del Modal ("Achatado"):**
        -   **Problema:** El modal de detalles se mostraba visualmente colapsado.
        -   **Diagnóstico:** Se identificó que el componente `InternmentDetailModal`, que es un modal de página completa, estaba siendo envuelto incorrectamente por un componente de modal genérico más pequeño.
        -   **Solución:** Se eliminó el `Modal` genérico contenedor en la página de autorizaciones, permitiendo que el `InternmentDetailModal` se renderizara directamente y ocupara el espacio correcto.
- **Resultado:** Se ha completado y estabilizado con éxito el flujo de trabajo para el rol de `operador`. El usuario ahora puede crear una internación, verla inmediatamente en el tablero de gestión, abrir sus detalles, y realizar acciones sobre ella, con una experiencia de usuario fluida y sin errores visuales o de datos.

---
## 6. Esquema de la Base de Datos (PostgreSQL)

Esta sección documenta la estructura de las tablas principales de la base de datos para referencia.

### Tabla: `users`
- `id`: SERIAL PRIMARY KEY
- `name`: VARCHAR
- `role`: VARCHAR (ej. 'admin', 'auditor')
- `email`: VARCHAR UNIQUE
- `password`: VARCHAR (hash)
- `status`: VARCHAR

### Tabla: `prestadores`
- `id`: SERIAL PRIMARY KEY
- `razonsocial`: VARCHAR
- `cuit`: VARCHAR
- `email`: VARCHAR UNIQUE
- `password`: VARCHAR (hash)
- `estado`: VARCHAR
- `nombre_fantasia`: VARCHAR

### Tabla: `internments`
- `id`: BIGINT PRIMARY KEY
- `beneficiary_name`: VARCHAR
- `beneficiary_cuil`: VARCHAR
- `admission_datetime`: TIMESTAMP
- `carácter`: VARCHAR
- `admission_reason`: TEXT
- `attending_doctor`: VARCHAR
- `notifying_provider_id`: INTEGER (FK a `prestadores.id`)
- `status`: VARCHAR
- `source`: VARCHAR
- `details`: JSONB
- `created_at`: TIMESTAMP
- `egreso_date`: TIMESTAMP
- `admission_type`: VARCHAR
- `admission_sector`: VARCHAR
- `room_number`: VARCHAR
- `presumptive_diagnosis`: VARCHAR
- `clinical_summary`: TEXT
- `documentation`: JSONB

### Tabla: `authorizations`
- `id`: SERIAL PRIMARY KEY
- `created_at`: TIMESTAMP
- `type`: VARCHAR
- `title`: VARCHAR
- `beneficiary_name`: VARCHAR
- `status`: VARCHAR
- `is_important`: BOOLEAN
- `details`: JSONB
- `provider_id`: INTEGER (FK a `prestadores.id`)
- `auditor_id`: INTEGER (FK a `users.id`)
- `internment_id`: BIGINT (FK a `internments.id`)

### Tabla: `notifications`
- `id`: SERIAL PRIMARY KEY
- `provider_id`: INTEGER (FK a `prestadores.id`)
- `interment_id`: BIGINT (FK a `internments.id`)
- `message`: TEXT
- `is_read`: BOOLEAN
- `created_at`: TIMESTAMP 

### Fase 22: Mejoras de UX y Nuevas Funcionalidades Estratégicas (Completada)

-   **Requerimiento:** Implementar una serie de mejoras en la interfaz de usuario del modal de internaciones y añadir nuevas funcionalidades clave para la gestión interna.
-   **Decisión Arquitectónica:** Se optó por un enfoque escalable y modular para las nuevas funcionalidades, asegurando que las soluciones no solo resolvieran el problema inmediato, sino que también prepararan la aplicación para futuras expansiones.
-   **Acciones Técnicas Realizadas:**
    1.  **Reorganización del Modal de Internaciones:**
        -   Se eliminó la sección genérica "Acciones Disponibles" para una interfaz más limpia.
        -   La acción "Adjuntar Documentación" se movió a la sección de "Documentación Adjunta".
        -   La acción "Solicitar Auditoría In Situ" se reubicó en una nueva sección dedicada, "Auditorías In Situ", mejorando la organización contextual.
    2.  **Implementación de Enlaces Públicos para Compartir:**
        -   **Diseño Escalable:** Se creó una nueva tabla central `share_links` en la base de datos. Esta tabla gestiona los enlaces para cualquier tipo de recurso (internaciones, prácticas, etc.), evitando la necesidad de modificar tablas existentes en el futuro.
        -   **Backend:** Se crearon dos endpoints genéricos: `POST /api/share` para generar los tokens de forma segura, y `GET /api/public/share/[token]` para obtener los datos de forma anónima.
        -   **Frontend:** Se creó una nueva página pública (`/share/[token]`) que renderiza el recurso compartido en modo de solo lectura, reutilizando los componentes existentes.
    3.  **Sistema de Modales Flexibles:**
        -   Se refactorizó el componente `Modal` genérico para aceptar una prop `size`, permitiendo controlar su ancho (`sm`, `md`, `lg`, etc.) desde el componente que lo llama.
        -   Se aplicó este nuevo sistema para corregir un bug visual donde el formulario de solicitud de auditoría se veía "comprimido".
    4.  **Implementación de "Período de Embargo" para Auditorías:**
        -   **Base de Datos:** Se creó desde cero la tabla `field_audits`, incorporando desde el inicio una columna `notify_provider_after_hours` y otros campos para la medición de rendimiento (fechas programadas vs. reales).
        -   **Frontend:** Se actualizó el formulario de solicitud de auditoría para incluir un campo numérico donde el operador puede especificar el número de horas de retraso.
        -   **Backend (Lógica de Visibilidad):** Se modificó el endpoint del portal de prestadores (`GET /api/portal/internments/[id]`) para que la consulta SQL filtre y muestre únicamente las auditorías cuyo período de embargo haya finalizado, garantizando que la lógica de negocio resida de forma segura en el servidor.

-   **Resultado:** La aplicación ha ganado funcionalidades estratégicas clave (compartir y embargo de auditorías) construidas sobre una arquitectura robusta y escalable. Además, se han implementado mejoras significativas en la experiencia de usuario, resultando en una interfaz más limpia, organizada y flexible. 

### Fase 23: Sistema de Notificaciones de Urgencia para Auditorías de Terreno (Completada)

-   **Requerimiento:** Implementar un sistema completo de notificaciones para auditorías marcadas como "urgentes", que incluya indicadores visuales, notificaciones en la plataforma y envío automático de correos electrónicos.
-   **Decisión Arquitectónica:** Se optó por un enfoque multicapa que garantice que las auditorías urgentes sean visibles y notificadas de forma inmediata y efectiva, utilizando tanto la interfaz de usuario como canales de comunicación externos.
-   **Acciones Técnicas Realizadas:**
    1.  **Indicadores Visuales en la Interfaz:**
        -   Se modificó el componente `InternmentDetailModal.jsx` para mostrar auditorías urgentes con un ícono de exclamación rojo (`ExclamationCircleIcon`) junto al nombre del auditor asignado.
        -   Se añadió un fondo ligeramente rojizo (`bg-red-50`) a las filas de auditorías urgentes en la lista para destacarlas visualmente.
        -   Se importó el ícono necesario desde Heroicons y se implementó la lógica condicional de renderizado.
    2.  **Sistema de Correos Electrónicos:**
        -   **Configuración de Infraestructura:** Se instaló `nodemailer` y se configuró para conectarse al servidor SMTP de Donweb (`c2851035.ferozo.com:465`) usando la cuenta `contacto@synapsys.site`.
        -   **Módulo Reutilizable:** Se creó `src/lib/email.js` con una función `sendMail()` que maneja el envío de correos de forma segura, incluyendo manejo de errores y logging.
        -   **Variables de Entorno:** Se configuraron las credenciales SMTP en `.env.local` de forma segura, separando la configuración del código.
    3.  **Notificaciones en la Plataforma:**
        -   Se modificó el endpoint `POST /api/internments/[id]/field-audits` para que, cuando una auditoría sea marcada como urgente, se inserte automáticamente un registro en la tabla `notifications`.
        -   La notificación incluye un mensaje claro indicando la urgencia y un enlace directo a los detalles de la internación.
    4.  **Integración Completa en el Backend:**
        -   Se actualizó la API para obtener el email del auditor asignado desde la tabla `users`.
        -   Se implementó el envío de correos electrónicos con formato HTML profesional, incluyendo:
            -   Asunto claro: `[URGENTE] Nueva Auditoría de Terreno Asignada`
            -   Información del beneficiario y ID de internación
            -   Formato HTML con estilos y estructura clara
            -   Versión en texto plano como respaldo
        -   Todo el proceso se ejecuta dentro de transacciones de base de datos para garantizar consistencia.
    5.  **Pruebas y Validación:**
        -   Se creó un script de prueba temporal (`test-email.js`) para validar la configuración SMTP.
        -   Se confirmó el funcionamiento exitoso del envío de correos a través del servidor de Donweb.
        -   Se eliminó el archivo de prueba tras la validación exitosa.

-   **Resultado:** El sistema ahora cuenta con un mecanismo completo de notificaciones de urgencia que funciona en tres niveles:
    1.  **Visual:** Las auditorías urgentes se destacan claramente en la interfaz con íconos y colores distintivos.
    2.  **Plataforma:** Se generan notificaciones automáticas en el sistema interno para el auditor asignado.
    3.  **Email:** Se envían correos electrónicos inmediatos con información detallada y formato profesional.
    
    Esta implementación garantiza que las auditorías urgentes reciban la atención inmediata que requieren, mejorando significativamente la eficiencia del flujo de trabajo y la comunicación entre el equipo interno y los auditores. 
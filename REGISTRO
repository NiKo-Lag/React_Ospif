# REGISTRO DEL PROYECTO - Portal de Gestión OSPIF

Este documento sirve como un registro centralizado del estado, la arquitectura y las decisiones de diseño del proyecto. Se actualizará continuamente a medida que el proyecto evolucione.

---

## 1. Idea General del Proyecto

El proyecto es una aplicación web construida con Next.js que funciona como un portal de gestión para una entidad de salud (posiblemente una obra social o seguro médico). Su funcionalidad principal, hasta ahora, se centra en permitir que los "prestadores" (clínicas, hospitales, etc.) gestionen los procesos de internación de los beneficiarios.

El flujo principal permite a un prestador:
- Autenticarse en un portal seguro.
- Denunciar nuevas internaciones.
- Ver un panel con todas sus internaciones activas y finalizadas.
- Gestionar una internación existente:
    - Solicitar prórrogas.
    - Adjuntar documentación.
    - Finalizar la internación.
- Recibir notificaciones sobre eventos relevantes.

El sistema también presupone la existencia de otros roles, como "Auditores" y "Administradores", aunque sus flujos de trabajo aún no están implementados.

---

## 2. Estructura del Proyecto

El proyecto sigue las convenciones del App Router de Next.js. La estructura principal es la siguiente:

- **`/src/app/`**: Contiene todas las rutas de la aplicación y la lógica de la API.
    - **`/src/app/api/`**: Alberga todos los endpoints del backend, organizados por roles y recursos (ej. `/portal/login`, `/portal/internments`).
    - **`/src/app/portal/`**: Define las rutas del portal de prestadores, que es el área principal para usuarios autenticados. Utiliza un grupo de rutas `(main)` para aplicar un layout específico.
    - **`/src/app/login/`**: (Actualmente no existe como página, pero es una ruta implícita).

- **`/src/components/`**: Contiene todos los componentes reutilizables de React, tanto de UI (`/ui/Modal`) como de lógica de negocio (`/internaciones/ProrrogaForm`).

- **`/src/lib/`**: Contiene lógica y helpers compartidos.
    - `auth.js`: Lógica de autenticación (verificación de tokens JWT).
    - `db.js`: Configuración de la conexión a la base de datos PostgreSQL.

- **`/src/middleware.js`**: (Recientemente añadido) Intercepta las peticiones para proteger las rutas y gestionar las redirecciones basadas en la autenticación.

- **`/storage/`**: Directorio (creado dinámicamente) donde se almacenan los archivos subidos, como la documentación de las internaciones.

---

## 3. Módulos y Relaciones

### a. Módulo de Autenticación

- **Tecnología:** Basado en tokens JWT.
- **Flujo Actual:**
    1. Un "prestador" envía su email y contraseña al endpoint `/api/portal/login/route.js`.
    2. El servidor verifica las credenciales contra la tabla `prestadores` y, si son válidas, genera un JWT.
    3. El token se almacena en una cookie `httpOnly` llamada `provider_token`.
- **Componentes Clave:**
    - `src/lib/auth.js`: Contiene `getSession` y `verifyToken`, helpers para gestionar la sesión.
    - `src/middleware.js`: Protege todas las rutas del portal, redirigiendo al login si no hay un token válido.
- **Estado Actual y Problemas:**
    - **INCONSISTENTE:** Existe una gran inconsistencia en todo el proyecto. Muchos endpoints buscan una cookie llamada `token` en lugar de `provider_token`, lo que hace que fallen.
    - **CÓDIGO DUPLICADO:** La lógica de verificación de token está repetida en casi todos los endpoints y layouts, en lugar de estar centralizada.
    - **FUNCIONALIDADES FALTANTES:** No existen flujos para el registro de usuarios, la recuperación de contraseña o el login de otros roles.

### b. Módulo de Gestión de Internaciones

- **Corazón de la Aplicación:** Es el módulo más desarrollado y complejo.
- **UI Principal:** `src/app/portal/(main)/internments-panel/page.jsx`. Es un componente de cliente complejo que gestiona el estado de la tabla de internaciones y la visibilidad de numerosos modales.
- **API de Soporte:** `src/app/api/portal/internments/`
    - `POST /`: Crea una nueva denuncia de internación, incluyendo la subida de archivos iniciales.
    - `GET /[id]`: Obtiene los detalles completos de una internación.
    - `PATCH /[id]/request-extension`: Añade una solicitud de prórroga al historial de la internación.
    - `PATCH /[id]/upload`: Adjunta nueva documentación a una internación existente.
    - `PATCH /[id]/finalize`: Cambia el estado de la internación a "Finalizada" y registra los detalles del egreso.
- **Relación:** El panel de la UI consume intensivamente estos endpoints para proveer la funcionalidad al prestador.

### c. Módulo de Notificaciones

- **UI:** `src/components/NotificationBell.jsx`. Un componente de cliente que se encarga de mostrar un ícono de campana con las notificaciones no leídas.
- **API de Soporte:** `src/app/api/portal/notifications/`
    - `GET /`: Obtiene todas las notificaciones para el usuario autenticado.
    - `PATCH /[id]`: Marca una notificación específica como leída.
- **Estado Actual:**
    - **NO FUNCIONAL:** Todo el módulo de notificaciones está actualmente roto debido a la inconsistencia en el nombre de la cookie de autenticación que busca en sus endpoints.

### d. Módulo de Auditoría

- **Rol Implícito:** Aunque no tiene una interfaz de usuario visible, el rol de "auditor" es fundamental para el flujo de negocio.
- **Flujo de Trabajo:**
    1. Un "prestador" realiza una acción que requiere aprobación (ej. solicitar una prórroga).
    2. Esta acción crea una "autorización" con el estado `Pendiente de Auditoría`.
    3. Un usuario con el rol de "auditor" debe iniciar sesión (mecanismo aún no descubierto).
    4. El auditor utiliza el endpoint `PATCH /api/auditor/authorizations/[id]` para aprobar, rechazar o devolver la solicitud.
- **Endpoint Clave:** `src/app/api/auditor/authorizations/[id]/route.js`
    - **Verificación de Rol:** Es el único endpoint que verifica explícitamente que el usuario tenga `role: 'auditor'`.
    - **Lógica Detallada:** Actualiza el estado de la autorización, guarda el ID del auditor, la fecha y un comentario.
- **Estado Actual y Problemas:**
    - **FUNCIONALIDAD INCOMPLETA:** No existe un endpoint de login para auditores ni una interfaz de usuario donde puedan ver y gestionar las autorizaciones pendientes. El flujo de trabajo está definido en el backend pero no es utilizable por un usuario final.
    - **INCONSISTENCIA DE AUTENTICACIÓN:** Sufre de los mismos problemas de manejo de tokens que el resto de la aplicación.

### e. Módulo de Administración

- **Rol Placeholder:** La existencia del directorio `/api/admin` sugiere un rol de administrador.
- **Funcionalidades Previstas:** La estructura de subdirectorios (`/users`, `/kpis`) indica que este rol debería encargarse de la gestión de usuarios y la visualización de indicadores.
- **Estado Actual:**
    - **NO IMPLEMENTADO:** Los directorios que contendrían la lógica de la API para este rol están completamente vacíos. Es un rol puramente conceptual en esta etapa del proyecto.

### f. Integración con API Externa (SAAS)

- **Descubrimiento Arquitectónico:** El proyecto no gestiona su propio padrón de beneficiarios. Actúa como un intermediario (Backend-For-Frontend) que consulta una API de terceros para esta información.
- **Endpoint Clave:** `GET /api/beneficiary/[cuil]`
    - Este endpoint es consumido por el asistente de denuncia de internación para validar y obtener los datos del paciente.
- **Flujo de Interacción:**
    1. El backend de la aplicación recibe la petición del frontend.
    2. Se autentica contra la API de SAAS (`https://fosforo.client-api.saas.com.ar/api`) usando credenciales fijas para obtener un token temporal.
    3. Utiliza ese token para consultar el padrón de SAAS con el CUIL proporcionado.
    4. Normaliza los datos recibidos (ej. corrige nombres faltantes) y los devuelve al frontend.
- **Estado Actual y Problemas:**
    - **VULNERABILIDAD DE SEGURIDAD:** Las credenciales para la API de SAAS están hardcodeadas en el código fuente en lugar de usar variables de entorno. Esto es un riesgo de seguridad crítico.
    - **INCONSISTENCIA DE AUTENTICACIÓN:** El endpoint que envuelve esta lógica sufre del mismo problema de verificación de tokens que el resto de la aplicación.

### g. Dependencias y Configuración del Proyecto (package.json)

- **Descubrimiento Crítico (Contradicción):** El archivo `package.json` incluye la dependencia `@auth0/nextjs-auth0`. Esto contradice frontalmente el sistema de autenticación manual (JWT + bcrypt) que está implementado en todo el proyecto.
- **Hipótesis Principal:** El proyecto probablemente comenzó o intentó una migración hacia Auth0, pero esta fue abandonada. El sistema de autenticación manual existente es el resultado de esa decisión, pero quedó en un estado inconsistente y a medio terminar. El directorio `/src/app/api/auth/[...auth0]/` (actualmente vacío) es un remanente de este intento.
- **Múltiples Bases de Datos:** Se declaran dependencias tanto para `pg` (PostgreSQL) como para `better-sqlite3` (SQLite). Toda la lógica de negocio visible utiliza PostgreSQL. SQLite podría haber sido usado en una fase temprana o para desarrollo local.
- **Stack Tecnológico:**
    - **Framework:** Next.js
    - **UI:** React, TailwindCSS, Framer Motion, Heroicons
    - **Backend:** Node.js
    - **Bases de Datos:** PostgreSQL, (posiblemente SQLite)

### h. Scripts de Utilidad

- **`hashPassword.js`:**
    - **Propósito:** Un script de línea de comandos para generar hashes de contraseñas usando `bcrypt`.
    - **Flujo de Trabajo Implícito:** Confirma que la creación de usuarios y la asignación de contraseñas se realizan de forma manual, directamente en la base de datos. El script facilita la generación del hash necesario para las consultas SQL.
    - **Implicación:** Refuerza la conclusión de que las funcionalidades de registro de usuarios y gestión de perfiles son inexistentes en la aplicación.

---
## 4. Estado General y Próximos Pasos (Inicial)

El proyecto tiene una base de lógica de negocio muy sólida y bien implementada, principalmente para el rol de "prestador". Su arquitectura es más compleja de lo que parecía inicialmente, funcionando como un orquestador entre su propia base de datos (PostgreSQL) y un servicio externo (SAAS) para el padrón de afiliados.

Sin embargo, está severamente afectado por un sistema de autenticación fragmentado, inconsistente y a medio hacer. Los roles de "auditor" y "admin" están en fases muy tempranas de desarrollo y no son funcionales.

**El primer gran objetivo, antes de añadir cualquier nueva funcionalidad, será refactorizar y unificar todo el sistema de autenticación.** Esto implicará:
1. Estandarizar el uso de `getSession` en todos los endpoints y layouts para obtener la sesión del usuario.
2. Eliminar toda la lógica de verificación de tokens duplicada.
3. Asegurar que todos los endpoints utilicen el nombre de cookie correcto.
4. Corregir los módulos que actualmente no funcionan (como Notificaciones) como resultado de este refactor.

---
## 5. Plan de Acción y Decisiones Arquitectónicas

### Fase 1: Limpieza y Actualización (Completada)

- **Decisión:** Antes de implementar cualquier funcionalidad nueva o corregir los problemas existentes, se decidió actualizar la base tecnológica del proyecto y eliminar el código muerto y las dependencias no utilizadas.
- **Acciones Realizadas:**
    1.  Se actualizaron las dependencias principales (`next`, `react`, `react-dom`) a sus últimas versiones estables.
    2.  Se desinstaló el paquete `@auth0/nextjs-auth0`.
    3.  Se eliminó el directorio de API remanente `src/app/api/auth`.
- **Resultado:** El proyecto ahora se ejecuta sobre una versión moderna de Next.js y está libre de los restos de la integración abandonada con Auth0.

### Fase 2: Implementación de NextAuth (Próximo Paso)

- **Decisión Arquitectónica:** Se ha decidido utilizar **NextAuth.js** (ahora parte de Auth.js) como la librería principal para gestionar toda la autenticación y autorización.
- **Justificación:**
    - Es el estándar de facto para la autenticación en aplicaciones Next.js.
    - Centraliza toda la lógica de autenticación (logins, sesiones, tokens, etc.) en un único lugar, eliminando el código duplicado y las inconsistencias.
    - Es altamente extensible y nos permitirá implementar fácilmente diferentes "providers" de credenciales para los distintos roles (Prestadores, Auditores, etc.).
    - Proporciona ganchos y helpers del lado del cliente y del servidor (`useSession`, `getSession`) que simplificarán enormemente el código en los componentes y las API routes.
- **Plan de Implementación:**
    1. Instalar NextAuth.
    2. Crear el endpoint "catch-all" `src/app/api/auth/[...nextauth]/route.js`.
    3. Configurar el "CredentialsProvider" para manejar el login de los "Prestadores" (validando contra la base de datos con `bcrypt`).
    4. Refactorizar todos los endpoints de la API y los componentes de la UI para utilizar los helpers de NextAuth (`getSession`, `useSession`) en lugar de la lógica manual de verificación de tokens.
    5. Asegurar que el `middleware` utilice la lógica de NextAuth para proteger las rutas.
    6. Eliminar el código de autenticación manual obsoleto (`src/lib/auth.js`).

### Fase 3: Desarrollo de Nuevas Funcionalidades (Próximo Paso)

- **Decisión:** Habiendo establecido una base de código estable y moderna, el siguiente paso es abordar las funcionalidades incompletas o inexistentes.
- **Plan Propuesto:**
    1.  **Implementar el login para el rol de "Auditor"**: Añadir un segundo `CredentialsProvider` o una lógica condicional en el existente para manejar el login de auditores.
    2.  **Desarrollar la Interfaz de Usuario del Auditor**: Crear las páginas y componentes necesarios para que un auditor pueda ver su panel de autorizaciones pendientes y actuar sobre ellas.
    3.  **Implementar el Flujo de Registro de Usuarios (Prestadores)**: Crear la página de registro y el endpoint de API correspondiente.
    4.  **Implementar la Recuperación de Contraseña.**
    5.  **Desarrollar las funcionalidades del rol de "Admin"**.

### Fase 4: Unificación de la Página de Login (Completada)

- **Decisión Arquitectónica:** Se decidió unificar el punto de entrada de la aplicación en una única página de login genérica para todos los roles, en lugar de tener páginas separadas (ej. `/portal/login`, `/auditor/login`).
- **Justificación:** Mejora la experiencia de usuario, simplifica el mantenimiento y refuerza el concepto de una única aplicación con diferentes roles.
- **Acciones Realizadas:**
    1.  Se creó una nueva página de login en `src/app/login/page.jsx`, conservando el diseño visual preferido.
    2.  Se actualizó la configuración de NextAuth (`pages: { signIn: '/login' }`) para que todas las redirecciones de autenticación apunten a esta nueva página.
    3.  Se refactorizó la lógica de `authorize` en el `CredentialsProvider` para que sea capaz de buscar usuarios en diferentes tablas (actualmente busca en `prestadores` y está preparado para buscar en `users`).
    4.  Se eliminó la antigua página de login (`/src/app/portal/login`).
- **Resultado:** La aplicación ahora tiene un único punto de entrada de autenticación, más limpio, escalable y fácil de mantener.

### Fase 17: Implementación del Rol de Operador y Refinamiento del Flujo de Auditoría (Completada)

- **Requerimiento:** Introducir un nuevo rol de usuario, `operador`, con permisos para crear y gestionar solicitudes de autorización antes de que pasen a auditoría, y refinar las reglas de negocio sobre cuándo se notifican las acciones de auditoría a los prestadores.
- **Decisión Arquitectónica:** Se decidió integrar el nuevo rol en los flujos y componentes existentes para mantener la coherencia y reutilizar el código. La lógica de negocio más compleja y específica se centralizó en el backend para garantizar la seguridad y la correcta aplicación de las reglas.
- **Acciones Técnicas Realizadas:**
    1.  **Creación del Rol `operador`:**
        -   Se actualizó el layout de gestión interna (`/app/(app)/layout.js`) para reconocer el rol `operador`, proporcionándole un menú con acceso al Dashboard y a la página de Autorizaciones.
        -   Se actualizaron los permisos en los endpoints de la API relevantes (`PATCH /api/autorizaciones/[id]`) para permitir que los operadores realicen acciones específicas, como cambiar el estado de una solicitud.
    2.  **Implementación del Flujo "Enviar a Auditoría":**
        -   Se potenció el modal de detalle de la autorización (`AuthorizationForm.jsx`) para que muestre un botón "Enviar a Auditoría" de forma condicional.
        -   Este botón es visible únicamente para el rol `operador` y solo cuando la solicitud se encuentra en el estado `'Nuevas Solicitudes'`.
        -   Al hacer clic, el botón llama al endpoint `PATCH /api/autorizaciones/[id]` para cambiar el estado a `'En Auditoría'`, registrando automáticamente el evento en la trazabilidad.
    3.  **Refinamiento de la Lógica de Notificaciones:**
        -   Se modificó el endpoint de acciones del auditor (`PATCH /api/auditor/authorizations/[id]`) para implementar una lógica de notificación diferencial y más precisa.
        -   **Para autorizaciones asociadas a internaciones (`internment_id` no es nulo):** Se notifica al prestador de cualquier acción relevante del auditor (Aprobar, Rechazar, Devolver).
        -   **Para autorizaciones independientes (`internment_id` es nulo):** Solo se notifica al prestador si la solicitud es **aprobada**, ya que es el único caso que requiere una acción por su parte.
- **Resultado:** Se ha definido y materializado un nuevo rol de `operador` con un flujo de trabajo claro y seguro dentro del sistema. Además, la lógica de comunicación con el prestador se ha hecho más inteligente y contextual, evitando notificaciones innecesarias y asegurando que la información llegue en el momento preciso, de acuerdo con las reglas de negocio.

### Fase 18: Módulo de Auditorías de Terreno (Completada)

- **Requerimiento:** Implementar una nueva funcionalidad que permita al personal interno solicitar una auditoría presencial (de terreno) para una internación específica, asignarla a un médico auditor y que este último pueda registrar el resultado de su visita.
- **Decisión Arquitectónica:** Se diseñó un flujo de trabajo de dos fases (solicitud y ejecución) y se crearon nuevas tablas en la base de datos (`field_audits`, `field_audit_documents`) para dar soporte a esta funcionalidad de forma aislada pero relacionada con las internaciones.
- **Acciones Técnicas Realizadas:**
    1.  **Ampliación del Esquema de la Base de Datos:**
        -   Se crearon dos nuevas tablas: `field_audits` para almacenar la información de la auditoría (quién solicita, a quién se asigna, estado, etc.) y `field_audit_documents` para futuros adjuntos.
    2.  **Backend (API para el Flujo Completo):**
        -   Se creó el endpoint `POST /api/internments/[id]/field-audits` para que un usuario con rol `operador` o `admin` pueda crear una solicitud de auditoría, asignándola a un auditor específico.
        -   Se creó el endpoint `PUT /api/field-audits/[audit_id]` para que el auditor asignado pueda completar el informe, actualizando el estado de la auditoría y registrando los detalles de la visita (fecha, observaciones, checklist).
    3.  **Frontend (Integración en la Interfaz Existente):**
        -   Se modificó el modal de detalle de la internación (`InternmentDetailModal.jsx`) para añadir una nueva sección "Acciones Disponibles", donde los usuarios autorizados ven un botón para "Solicitar Auditoría Terreno".
        -   Al hacer clic, se abre un nuevo modal con el formulario `FieldAuditRequestForm.jsx`, que permite seleccionar al auditor y añadir un motivo.
        -   Se añadió una sección "Auditorías de Terreno" en el mismo modal de detalle, que lista todas las auditorías asociadas a esa internación, mostrando su estado (`Pendiente`, `Completada`).
        -   Si una auditoría está pendiente y el usuario actual es el auditor asignado, se muestra un botón "Completar Informe", que abre el formulario `FieldAuditCompletionForm.jsx`.
- **Resultado:** La aplicación ahora cuenta con un ciclo de vida completo para las auditorías de terreno. El proceso es claro, trazable y está perfectamente integrado en la vista de detalle de la internación, permitiendo una gestión centralizada de todas las actividades relacionadas sin abandonar el contexto del paciente.

### Fase 19: Flujo de Envío a Auditoría para Internaciones (Completada)

- **Requerimiento:** Crear un mecanismo para que el personal interno (rol `operador` o `admin`) pueda iniciar formalmente el proceso de auditoría para una internación que se encuentra en estado `INICIADA`.
- **Problema Detectado:** El sistema solo contemplaba que una auditoría se iniciara como consecuencia de una acción del prestador (ej. solicitar prórroga), pero no existía una vía para que el equipo interno disparara este proceso proactivamente.
- **Decisión Arquitectónica:** Se decidió implementar un flujo que es coherente con el resto de la aplicación: la acción del operador debe crear una `autorización` vinculada a la `internación`. Esta nueva autorización será el vehículo para el proceso de auditoría, centralizando la lógica en el módulo de autorizaciones ya existente.
- **Acciones Técnicas Realizadas:**
    1.  **Backend (Nuevo Endpoint Dedicado):**
        -   Se creó el endpoint `POST /api/internments/[id]/send-to-audit`.
        -   Este endpoint realiza una operación atómica (envuelta en una transacción) que:
            a.  Verifica que el usuario sea `operador` o `admin`.
            b.  Valida que la internación esté en estado `INICIADA`.
            c.  Crea un nuevo registro en la tabla `authorizations` de tipo "Internación", con estado `'En Auditoría'` y con los datos relevantes de la internación.
            d.  Actualiza el estado de la `internment` original a `'EN AUDITORIA'`.
    2.  **Frontend (Integración en la Interfaz de Operador):**
        -   Se modificó el modal de detalle de la internación (`InternmentDetailModal.jsx`).
        -   Se añadió un nuevo botón, "Enviar a Auditoría", en la sección de "Acciones Disponibles".
        -   Este botón es visible únicamente para los roles `operador` y `admin`, y solo cuando la internación se encuentra en estado `INICIADA`.
        -   Al hacer clic, el botón llama al nuevo endpoint, proporcionando feedback visual al usuario (estado de carga) y mostrando una notificación de éxito o error.
- **Resultado:** Se ha cerrado una brecha importante en el flujo de trabajo. El personal interno ahora tiene el control total para iniciar el proceso de auditoría de una internación en el momento oportuno, siguiendo un patrón de diseño consistente que aumenta la trazabilidad y reutiliza la lógica de negocio existente.

---
## 6. Esquema de la Base de Datos (PostgreSQL)

Esta sección documenta la estructura de las tablas principales de la base de datos para referencia.

### Tabla: `users`
- `id`: SERIAL PRIMARY KEY
- `name`: VARCHAR
- `role`: VARCHAR (ej. 'admin', 'auditor')
- `email`: VARCHAR UNIQUE
- `password`: VARCHAR (hash)
- `status`: VARCHAR

### Tabla: `prestadores`
- `id`: SERIAL PRIMARY KEY
- `razonsocial`: VARCHAR
- `cuit`: VARCHAR
- `email`: VARCHAR UNIQUE
- `password`: VARCHAR (hash)
- `estado`: VARCHAR
- `nombre_fantasia`: VARCHAR

### Tabla: `internments`
- `id`: BIGINT PRIMARY KEY
- `beneficiary_name`: VARCHAR
- `beneficiary_cuil`: VARCHAR
- `admission_datetime`: TIMESTAMP
- `carácter`: VARCHAR
- `admission_reason`: TEXT
- `attending_doctor`: VARCHAR
- `notifying_provider_id`: INTEGER (FK a `prestadores.id`)
- `status`: VARCHAR
- `source`: VARCHAR
- `details`: JSONB
- `created_at`: TIMESTAMP
- `egreso_date`: TIMESTAMP
- `admission_type`: VARCHAR
- `admission_sector`: VARCHAR
- `room_number`: VARCHAR
- `presumptive_diagnosis`: VARCHAR
- `clinical_summary`: TEXT
- `documentation`: JSONB

### Tabla: `authorizations`
- `id`: SERIAL PRIMARY KEY
- `created_at`: TIMESTAMP
- `type`: VARCHAR
- `title`: VARCHAR
- `beneficiary_name`: VARCHAR
- `status`: VARCHAR
- `is_important`: BOOLEAN
- `details`: JSONB
- `provider_id`: INTEGER (FK a `prestadores.id`)
- `auditor_id`: INTEGER (FK a `users.id`)
- `internment_id`: BIGINT (FK a `internments.id`)

### Tabla: `notifications`
- `id`: SERIAL PRIMARY KEY
- `provider_id`: INTEGER (FK a `prestadores.id`)
- `interment_id`: BIGINT (FK a `internments.id`)
- `message`: TEXT
- `is_read`: BOOLEAN
- `created_at`: TIMESTAMP 